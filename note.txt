
* Time complexity - Amount of time taken by an algorithm to run, as a function of input size
* Space complexity - Amount of memory taken by an algorithm to run, as a function of input size

1.Big-O Notation - Worst case complexity
2.Omega Notation - Best case complexity
3.Theta Notation - Average case complexity

Big-O notation : 
    - describes the complexity of an algorithm using algebraic terms
    - It has two important characteristics : 
        * It is expressed in terms of the input
        * It focuses on the bigger picture without getting caught up in the minute details
    * note : 
        - loop => Big O = O(n)
        - loop inside loop Big O = O(n ^ 2)
        - reduceed by half O = O(log n)
    - EXP1 :
    function summation(n) {
        let sum = 0;
        for (let i = 1; i <= n; i++) {
            sum += 1;
        }
        return sum;
    }

    Count the number of times a statement executes based on the input size
    Here if n = 4 so number of execution is 6 
    1 execution:  let sum = 0;
    4 executions: sum +=1;
    1 execution : return sum;

    So the algorithm here is n + 2 ( so numbers of execution depended on input size ) 
    If n = 10 so n+2 = 12 executions 
    If n = 1000 so n+2 = 1002 executions ( we can consider it 1000 ) 
    So we can consider time complexity O(n) linear 

    - EXP2 :
    function summation(n) {
        return (n * (n + 1)) / 2;
    }

    time complexity O(1) constant 
    ( so numbers of execution does not depend on input size (n argument ) 
        return statment will be executed only once)
    
    - Exp3:
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= i; i++) {
        //Some code
        }
    }

    Time Complexity O(n2) - Quadratic 

    - EXP4 :
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= i; i++) {
            for (k = 1; k <= j; k++) {
                //Some code
            }
        }
    }

Time Complexity O(n3) - Cubic

* Object Big-O Notation:

    Insert - O(1)
    Remove - O(1)
    Access - O(1)
    Search - O(n)
    Object.keys()-O(n)
    Object.values()-O(n)

* Array Big-O Notation:

    Insert / remove at end - O(1)
    Insert / remove at beginning - O(n)
    Access - O(1)
    Search - O(n)
    Push / pop -O(1)
    Shift / unshift / concat slice / splice - O(n)
    forEach / map / filter / reduce - O(n)

----- Math algorithm
* Fibonacci sequence ( see Exp. in main.js)
 
    the Fibonacci sequence is a sequence in which each number is the sum of the two preceding ones.
    The first two numbers in the sequence are 0 and 1.
    fibonacci(2) = [0,1]
    fibonacci(3) = [0,1,1]
    fibonacci(7) = [0,1,1,2,3,5,8]

    Big-O = O(n) linear ( because for loop inside function)

* Factorial of a number ( see Exp. in main.js)

    In mathematics, the factorial of a non-negative integer 'n', denoted n!, 
    is the product of all positive integers less than or equal to 'n'.

    Factorial of zero is 1.
    factorial(4) = 4*3*2*1 = 24
    factorial(5) = 5*4*3*2*1 = 120

    Big-O = O(n) linear ( because for loop inside function)

* Prime Number ( see Exp. in main.js) : 

    A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers.
    isPrime(5) = true (1*5 or 5*1)
    isPrime(4) = false ( 1*4 or 2*2 or 4*1)

    Big-O = O(n) linear ( because for loop inside function)

    - with optimized solution ( see main.js)
    - Optimized Primality Test
        Integers larger than the square root do not need to be checked because,
        whenever 'n=a*b', one of the two factors 'a' and 'b' is less than or equal to the square root of 'n' n=24, a=4 and b=6
        The square root of 24 is 4.89
        4 is less than 4.89
        a is less than the square root of n n=35, a=5 and b=7
        The square root of 35 is 5.91
        5 is less than 5.91
        a is less than the square root of n
    Big-O = O(sqrt(n))

* Power of Two  ( see Exp. in main.js) :
    Problem - Give a positive integer 'n', determine if the number is a power of 2 or not
    An integer is a power of two if there exists an integer 'x' such that 'n' === 2x
    isPowerOfTwo(1) = true (2 power 0)
    isPowerOfTwo(2) = true (2 power 1)
    isPowerOfTwo(5) = false

    Vishwas solution Big-O = O(logn)
    My solution Big-O = O(1)
    Optimized solution (Bitwise operator solution) Big-O = O(1)

* recursive algorithm : 
    A recursive algorithm simplifies a problem by breaking it down into sub-problems of the same type. 
    The output of one recursion becomes the input for another recursion.
    It assists you in breaking down large complex problems into smaller ones.
     
    - recursive algorithm consists of :
    [1] Base case, which consists of a state and condition that ends the recursive function
    [2] Recursive Step: It computes the output by reaching the same function repeatedly but with smaller or more complex inputs.

* Recursive Fibonacci sequence ( see Exp. in main.js) :
    Problem - Give a number 'n', find the nth element of the Fibonacci sequence
    In mathematics, the Fibonacci sequence is a sequence in which each number is the sum of the two preceding ones.
    The first two numbers in the sequence are 0 and 1. (0, 1, 1, 2, 3, 5, 8...)
    recursiveFibonacci(0) = 0
    recursiveFibonacci(1) = 1
    recursiveFibonacci(6) = 8

    Recursive solution (Vishwas Solution) Big-O = O(2^n) 
    iteration solution ( my Solution) Big-O = O(n)
    so iteration solution is better performance than Recursive solution for Fibonacci sequence

* Recursive Factorial of a number ( see Exp. in main.js)

    In mathematics, the factorial of a non-negative integer 'n', denoted n!, 
    is the product of all positive integers less than or equal to 'n'.

    recursiveFactorial of zero is 1.
    recursiveFactorial(4) = 4*3*2*1 = 24
    recursiveFactorial(5) = 5*4*3*2*1 = 120

    Big-O = O(n) linear 

* Search algorithm
    [1] linear
    [2] Binary
    [3] Recursive Binary

* Linear Search  ( see Exp. in main.js)
    Problem - Given an array of 'n' elements and a target element 't', 
    find the index of 't' in the array. Return -1 if the target element is not found.

    Big-O = O(n) linear

* Binary Seacrh ( see Exp. in main.js) : 
    Problem - Given a sorted array of 'n' elements and a target element 't', find the index of 't' in the array. 
    Return -1 if the target element is not found.

    Binary search pseudocode: 
        [1] If the array is empty, return -1 as the element cannot be found.
        [2] If the array has elements, find the middle element in the array. If target is equal to the middle element, return the middle element index.
        [3] If target is less than the middle element, binary search left half of the array.
        [4] If target is greater than middle element, binary search right half of the array.
    
    Big-O = O(log n) 

* Recursive Binary Search ( see Exp. in main.js) :

    Big-O = O(log n) 

* Sorting algorithm
    [1] Bubble Sort
    [2] Insertion Sort
    [3] Quick Sort
    [4] Merge Sort

* Bubble Sorting ( see Exp. in main.js):
    compare every two adjacent numbers in the array and swap and repeat this loop till sorting all numbers

    Big-O = O(n ^ 2) 

* Insertion Sorting ( see Exp. in main.js): : 
    - difference between Bubble Sorting and Insertion Sorting : 
        [1] Bubble sorting compare every two adjacent numbers and swap and repeat this loop till array is sorted 
            (https://youtube.com/shorts/e30RDr-A4T8?si=vII103GN-COD8A9R)

        [2] Insertion sorting compare one number to each number behind it and put this number in it's right position 
            ( https://youtube.com/shorts/ZZ-Oz1IFfPg?si=4jkeyJx67r4RyiUh) 

    Big-O = O(n ^ 2) (but better berformance than Bubble Sorting)

* Quick Sorting ( recursive) ( see Exp. in main.js):

    - Quick sort idea
    [1] Identify the pivot element ( as refernce for comparison ) in the array ( as you like 1st element , last element or even random)
    [2] Put everything that's smaller than the pivot into a 'left' array 
        and everything that's greater than the pivot into a 'right' array
    [3] Repeat the process for the individual 'left' and 'right' arrays 
        till you have an array of length 1 which is sorted by definition
    [4] Repeatedly concatenate the left array, pivot and right array till one sorted array remains

    Big-O = O(n ^ 2) worst case complexity ( when you try to sort already sorted array)
    Theta Notation = O(nlogn) Average case complexity

* Merge Sorting ( recursive + 2 functions ) ( see Exp. in main.js):
    Merge sort idea
    [1] first function : Divide the array into sub arrays, 
        each containing only one element (An array with one element is considered sorted)
    [2] repeatedly merge the sub arrays to poduce new sorted sub arrays until there is only one sub
        array remaining . that will be sorted array

    Big-O = O(nlogn)

* Cartesian product( see Exp. in main.js):
    Problem - Given two finite non-empty sets, find their Cartesian Product.
    In mathematics, specifically set theory, the Cartesian product of two sets A and B, 
    denoted AxB, is the set of all ordered pairs (a, b) where a is in A and b is in B
    
    const A = [1, 2]
    const B = [3, 4]
    
    AxB = [ [1, 3], [1, 4], [2, 3], [2, 4]]
    const C = [1, 2]
    const D = [3, 4, 5]
    CxD =[  [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5] ]

    Big-O = O(mn) 
    loop inside loop should be n ^ 2 but we have two arrays maybe those arrays with different length 
    so will be (m x n) not n ^ 2 (n x n)

* Climbing staircase ( see Exp. in main.js):
    
    Problem - Given a staircase of 'n' steps, count the number of distinct ways to climb to the top.
    You can either climb 1 step or 2 steps at a time.
    n=1, climbingStaircase(1) = 1 (1)
    n=2, climbingStaircase(2) =2 (1, 1) and (2)
    n=3, climbingStaircase(3) =3 (1,1,1) (1, 2) and (2, 1)
    n=4, climbingStaircase(4) = 5 (1,1,1,1) (1,1,2) (1,2,1) (2,1,1) and (2,2)

    n4 => sum of steps of n3 and n2 so steps of n4 is 5
    n5 => sum of steps of n4 and n3 so steps of n5 is 8

    Big-O = O(n) linear

* Tower of Hanio ( see Exp. in main.js):

Tower of Hanoi
The objective of the puzzle is to move the entire stack to the last rod, obeying the following rules:
    * Only one disk may be moved at a time.
    * Each move consists of taking the upper disk from one of the stacks 
        and placing it on top of another stack or on an empty rod. And lastly,
    * smaller disk should be on the top.

    Big-O = O(2^n)